============================= test session starts ==============================
platform darwin -- Python 3.9.0, pytest-6.2.4, py-1.11.0, pluggy-0.13.1 -- /Users/macbook-pro/Documents/praktikum/api_group/env/bin/python
django: settings: api_yamdb.settings (from ini)
rootdir: /Users/macbook-pro/Documents/praktikum/api_group, configfile: pytest.ini
plugins: pythonpath-0.7.3, django-4.4.0
collecting ... collected 7 items

tests/test_03_genre.py::Test03GenreAPI::test_01_genre_not_auth FAILED    [ 14%]
tests/test_03_genre.py::Test03GenreAPI::test_02_genre FAILED             [ 28%]
tests/test_03_genre.py::Test03GenreAPI::test_03_category_fields_validation[data0-massage0] FAILED [ 42%]
tests/test_03_genre.py::Test03GenreAPI::test_03_category_fields_validation[data1-massage1] FAILED [ 57%]
tests/test_03_genre.py::Test03GenreAPI::test_03_category_fields_validation[data2-massage2] FAILED [ 71%]
tests/test_03_genre.py::Test03GenreAPI::test_04_genres_delete FAILED     [ 85%]
tests/test_03_genre.py::Test03GenreAPI::test_05_genres_check_permission FAILED [100%]

=================================== FAILURES ===================================
____________________ Test03GenreAPI.test_01_genre_not_auth _____________________

request = <WSGIRequest: GET '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fb4002be4c0>
request = <WSGIRequest: GET '/api/v1/genres/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

env/lib/python3.9/site-packages/django/core/handlers/base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x7fb4002be4c0>
request = <WSGIRequest: GET '/api/v1/genres/'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

env/lib/python3.9/site-packages/django/core/handlers/base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, path = '/api/v1/genres/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

env/lib/python3.9/site-packages/django/urls/resolvers.py:556: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdb20>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

env/lib/python3.9/site-packages/django/urls/resolvers.py:598: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb4106606a0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb4106606a0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421a24450, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421a34cd0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421a34cd0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421a36240, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x7fb4002be2b0>
request = <WSGIRequest: GET '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb4002b7580>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb410660160>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb410660160>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421a36030, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421a9a250>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421a9a250>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421a9e0e0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x7fb4219e7490>
request = <WSGIRequest: GET '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb421a35100>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb40023ecd0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb40023ecd0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421a9cea0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421a9aa90>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421a9aa90>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421aa3be0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x7fb4219eb190>
request = <WSGIRequest: GET '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb421a9d4c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb40023e460>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb40023e460>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb40023b450, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421aa8310>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421aa8310>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421aad2f0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x7fb4218e1c70>
request = <WSGIRequest: GET '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb4002bdd40>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb4219e0700>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb4219e0700>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421a9cbe0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421aa8b50>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421aa8b50>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421aadd40, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x7fb4218a8bb0>
request = <WSGIRequest: GET '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb4219fbe80>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb4219e00a0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb4219e00a0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421aadb30, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421ab73d0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421ab73d0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421ab67c0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x7fb4219e7220>
request = <WSGIRequest: GET '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb421ab3f00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb4219e0490>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb4219e0490>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421a82df0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421ab7c40>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421ab7c40>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421ac5190, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x7fb4219e7a30>
request = <WSGIRequest: GET '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb421a313c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb4219e0160>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb4219e0160>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421ab6f50, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421ac94c0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421ac94c0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421ac5be0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_03_genre.Test03GenreAPI object at 0x7fb42188b9d0>
client = <django.test.client.Client object at 0x7fb4002be460>

    def test_01_genre_not_auth(self, client):
>       response = client.get(self.GENRES_URL)

tests/test_03_genre.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
env/lib/python3.9/site-packages/django/test/client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
env/lib/python3.9/site-packages/django/test/client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
env/lib/python3.9/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
env/lib/python3.9/site-packages/django/test/client.py:714: in request
    response = self.handler(environ)
env/lib/python3.9/site-packages/django/test/client.py:145: in __call__
    response = self.get_response(request)
env/lib/python3.9/site-packages/django/core/handlers/base.py:130: in get_response
    response = self._middleware_chain(request)
env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: in inner
    response = response_for_exception(request, exc)
env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
env/lib/python3.9/site-packages/django/urls/resolvers.py:611: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
env/lib/python3.9/site-packages/django/utils/functional.py:48: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
env/lib/python3.9/site-packages/django/urls/resolvers.py:591: in urlconf_module
    return import_module(self.urlconf_name)
/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
api_yamdb/api_yamdb/urls.py:27: in <module>
    path('api/', include('api.urls')),
env/lib/python3.9/site-packages/django/urls/conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
api_yamdb/api/urls.py:3: in <module>
    from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet
api_yamdb/api/views.py:30: in <module>
    class GenreViewSet(viewsets.ModelViewSet):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError
---------------------------- Captured stdout setup -----------------------------
Operations to perform:
  Synchronize unmigrated apps: messages, rest_framework, rest_framework_simplejwt, staticfiles
  Apply all migrations: admin, auth, contenttypes, reviews, sessions, users
Synchronizing apps without migrations:
  Creating tables...
    Running deferred SQL...
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0001_initial... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying users.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying reviews.0001_initial... OK
  Applying sessions.0001_initial... OK
  Applying users.0002_alter_user_username... OK
---------------------------- Captured stderr setup -----------------------------
Creating test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
_________________________ Test03GenreAPI.test_02_genre _________________________

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <rest_framework.test.ForceAuthClientHandler object at 0x7fb421c1d970>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

env/lib/python3.9/site-packages/django/core/handlers/base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <rest_framework.test.ForceAuthClientHandler object at 0x7fb421c1d970>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

env/lib/python3.9/site-packages/django/core/handlers/base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, path = '/api/v1/genres/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

env/lib/python3.9/site-packages/django/urls/resolvers.py:556: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdb20>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

env/lib/python3.9/site-packages/django/urls/resolvers.py:598: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421c17790>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421c17790>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4106dfdf0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421c07df0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421c07df0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb400218df0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x7fb421c1d460>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb3e004e280>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421c19be0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421c19be0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb400218870, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421c07160>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421c07160>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb40022e450, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x7fb421c1d2e0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb3e0052940>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421c19c40>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421c19c40>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb400235920, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421c0a670>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421c0a670>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb400227be0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x7fb421c1d220>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb4002c2300>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421c19910>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421c19910>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4106c7f50, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421c0aa90>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421c0aa90>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4106e9be0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x7fb421c177f0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb3e004fc80>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421c19940>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421c19940>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb42197a500, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb400386520>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb400386520>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4106c2a80, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x7fb421c17700>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb3e004c5c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421c19670>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421c19670>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4106c2240, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb400387d00>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb400387d00>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb41065e240, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x7fb421c170d0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb410683340>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421c19490>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421c19490>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb41065e450, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb400387520>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb400387520>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb41064bdf0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x7fb421c170a0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb3e0060980>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421c193d0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421c193d0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb40023bbe0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421bf58e0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421bf58e0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4106b6d40, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_03_genre.Test03GenreAPI object at 0x7fb421c310d0>
admin_client = <rest_framework.test.APIClient object at 0x7fb421c2e400>
client = <django.test.client.Client object at 0x7fb421c1d790>

    def test_02_genre(self, admin_client, client):
        genres_count = 0
    
        data = {}
>       response = admin_client.post(self.GENRES_URL, data=data)

tests/test_03_genre.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
env/lib/python3.9/site-packages/rest_framework/test.py:295: in post
    response = super().post(
env/lib/python3.9/site-packages/rest_framework/test.py:209: in post
    return self.generic('POST', path, data, content_type, **extra)
env/lib/python3.9/site-packages/rest_framework/test.py:233: in generic
    return super().generic(
env/lib/python3.9/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
env/lib/python3.9/site-packages/rest_framework/test.py:285: in request
    return super().request(**kwargs)
env/lib/python3.9/site-packages/rest_framework/test.py:237: in request
    request = super().request(**kwargs)
env/lib/python3.9/site-packages/django/test/client.py:714: in request
    response = self.handler(environ)
env/lib/python3.9/site-packages/django/test/client.py:145: in __call__
    response = self.get_response(request)
env/lib/python3.9/site-packages/rest_framework/test.py:257: in get_response
    return super().get_response(request)
env/lib/python3.9/site-packages/django/core/handlers/base.py:130: in get_response
    response = self._middleware_chain(request)
env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: in inner
    response = response_for_exception(request, exc)
env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
env/lib/python3.9/site-packages/django/urls/resolvers.py:611: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
env/lib/python3.9/site-packages/django/utils/functional.py:48: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
env/lib/python3.9/site-packages/django/urls/resolvers.py:591: in urlconf_module
    return import_module(self.urlconf_name)
/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
api_yamdb/api_yamdb/urls.py:27: in <module>
    path('api/', include('api.urls')),
env/lib/python3.9/site-packages/django/urls/conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
api_yamdb/api/urls.py:3: in <module>
    from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet
api_yamdb/api/views.py:30: in <module>
    class GenreViewSet(viewsets.ModelViewSet):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError
______ Test03GenreAPI.test_03_category_fields_validation[data0-massage0] _______

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <rest_framework.test.ForceAuthClientHandler object at 0x7fb400489a90>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

env/lib/python3.9/site-packages/django/core/handlers/base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <rest_framework.test.ForceAuthClientHandler object at 0x7fb400489a90>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

env/lib/python3.9/site-packages/django/core/handlers/base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, path = '/api/v1/genres/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

env/lib/python3.9/site-packages/django/urls/resolvers.py:556: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdb20>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

env/lib/python3.9/site-packages/django/urls/resolvers.py:598: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb400484a00>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb400484a00>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb410663df0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb40046f220>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb40046f220>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421c3cf50, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x7fb400489fa0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb421b89a40>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb400484af0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb400484af0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421c3cb30, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb40046ce50>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb40046ce50>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421c46450, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x7fb400489a60>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb400487e00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb400484490>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb400484490>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421c279d0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb40046c340>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb40046c340>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb40039b030, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x7fb400488040>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb400416a00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb4004845e0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb4004845e0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421c3c030, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb40047a1c0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb40047a1c0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb40038b660, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x7fb4004887c0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb421b893c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb4004844f0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb4004844f0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb410670500, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb40046d370>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb40046d370>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb400369190, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x7fb400488610>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb421b89d00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb400484820>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb400484820>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb40038bf50, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb40046d100>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb40046d100>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb400369c90, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x7fb400488430>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb41065b400>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb400484730>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb400484730>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb400369a80, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb400481850>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb400481850>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4003757c0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x7fb400488130>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb3e0031180>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb4004847c0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb4004847c0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4003755b0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb400481490>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb400481490>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4003a62f0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_03_genre.Test03GenreAPI object at 0x7fb40048fb20>
data = {'name': 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaasimbols', 'slug': 'longname'}
massage = ('Проверьте, что при обработке POST-запроса к `{url}` проверяется длина поля `name`: название произведения не должно быть длиннее 256 символов.',)
admin_client = <rest_framework.test.APIClient object at 0x7fb400473f40>

    @pytest.mark.parametrize('data,massage', check_name_and_slug_patterns)
    def test_03_category_fields_validation(self, data, massage, admin_client):
>       response = admin_client.post(self.GENRES_URL, data=data)

tests/test_03_genre.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
env/lib/python3.9/site-packages/rest_framework/test.py:295: in post
    response = super().post(
env/lib/python3.9/site-packages/rest_framework/test.py:209: in post
    return self.generic('POST', path, data, content_type, **extra)
env/lib/python3.9/site-packages/rest_framework/test.py:233: in generic
    return super().generic(
env/lib/python3.9/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
env/lib/python3.9/site-packages/rest_framework/test.py:285: in request
    return super().request(**kwargs)
env/lib/python3.9/site-packages/rest_framework/test.py:237: in request
    request = super().request(**kwargs)
env/lib/python3.9/site-packages/django/test/client.py:714: in request
    response = self.handler(environ)
env/lib/python3.9/site-packages/django/test/client.py:145: in __call__
    response = self.get_response(request)
env/lib/python3.9/site-packages/rest_framework/test.py:257: in get_response
    return super().get_response(request)
env/lib/python3.9/site-packages/django/core/handlers/base.py:130: in get_response
    response = self._middleware_chain(request)
env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: in inner
    response = response_for_exception(request, exc)
env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
env/lib/python3.9/site-packages/django/urls/resolvers.py:611: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
env/lib/python3.9/site-packages/django/utils/functional.py:48: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
env/lib/python3.9/site-packages/django/urls/resolvers.py:591: in urlconf_module
    return import_module(self.urlconf_name)
/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
api_yamdb/api_yamdb/urls.py:27: in <module>
    path('api/', include('api.urls')),
env/lib/python3.9/site-packages/django/urls/conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
api_yamdb/api/urls.py:3: in <module>
    from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet
api_yamdb/api/views.py:30: in <module>
    class GenreViewSet(viewsets.ModelViewSet):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError
______ Test03GenreAPI.test_03_category_fields_validation[data1-massage1] _______

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <rest_framework.test.ForceAuthClientHandler object at 0x7fb421d05dc0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

env/lib/python3.9/site-packages/django/core/handlers/base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <rest_framework.test.ForceAuthClientHandler object at 0x7fb421d05dc0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

env/lib/python3.9/site-packages/django/core/handlers/base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, path = '/api/v1/genres/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

env/lib/python3.9/site-packages/django/urls/resolvers.py:556: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdb20>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

env/lib/python3.9/site-packages/django/urls/resolvers.py:598: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421d0b460>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421d0b460>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421c18030, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421ce9cd0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421ce9cd0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4004805b0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x7fb421d05f10>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb421d01ec0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421d0b130>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421d0b130>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb400496d40, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421ce9ee0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421ce9ee0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb3e00b4500, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x7fb421d05af0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb4106d61c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb400473fd0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb400473fd0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb40047da80, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421cfe850>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421cfe850>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb3e00c00e0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x7fb421d056a0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb400469f80>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421d02b20>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421d02b20>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4004962f0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421cfe130>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421cfe130>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb3e00c67c0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x7fb421d05cd0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb400200f00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421d02cd0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421d02cd0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4004803a0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421cdaa00>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421cdaa00>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb3e00cb2f0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x7fb421d05610>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb4106e1540>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421d02eb0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421d02eb0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421c29500, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421cddaf0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421cddaf0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb3e00cbdf0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x7fb421d05640>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb4106dc4c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421d02c10>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421d02c10>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb400480030, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb4004884c0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb4004884c0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb3e00ac3a0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x7fb421d031c0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb40042c100>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421cf0bb0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421cf0bb0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb3e00ac190, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb400489dc0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb400489dc0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421d52450, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_03_genre.Test03GenreAPI object at 0x7fb421d0b4f0>
data = {'name': 'longslug', 'slug': 'llllllllllllllllllllllllllllllllllllllllllllllllllsimbols'}
massage = ('Проверьте, что при обработке POST-запроса к `{url}` проверяется длина поля `slug`: его содержимое не должно быть длиннее 50 символов.',)
admin_client = <rest_framework.test.APIClient object at 0x7fb421d02850>

    @pytest.mark.parametrize('data,massage', check_name_and_slug_patterns)
    def test_03_category_fields_validation(self, data, massage, admin_client):
>       response = admin_client.post(self.GENRES_URL, data=data)

tests/test_03_genre.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
env/lib/python3.9/site-packages/rest_framework/test.py:295: in post
    response = super().post(
env/lib/python3.9/site-packages/rest_framework/test.py:209: in post
    return self.generic('POST', path, data, content_type, **extra)
env/lib/python3.9/site-packages/rest_framework/test.py:233: in generic
    return super().generic(
env/lib/python3.9/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
env/lib/python3.9/site-packages/rest_framework/test.py:285: in request
    return super().request(**kwargs)
env/lib/python3.9/site-packages/rest_framework/test.py:237: in request
    request = super().request(**kwargs)
env/lib/python3.9/site-packages/django/test/client.py:714: in request
    response = self.handler(environ)
env/lib/python3.9/site-packages/django/test/client.py:145: in __call__
    response = self.get_response(request)
env/lib/python3.9/site-packages/rest_framework/test.py:257: in get_response
    return super().get_response(request)
env/lib/python3.9/site-packages/django/core/handlers/base.py:130: in get_response
    response = self._middleware_chain(request)
env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: in inner
    response = response_for_exception(request, exc)
env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
env/lib/python3.9/site-packages/django/urls/resolvers.py:611: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
env/lib/python3.9/site-packages/django/utils/functional.py:48: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
env/lib/python3.9/site-packages/django/urls/resolvers.py:591: in urlconf_module
    return import_module(self.urlconf_name)
/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
api_yamdb/api_yamdb/urls.py:27: in <module>
    path('api/', include('api.urls')),
env/lib/python3.9/site-packages/django/urls/conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
api_yamdb/api/urls.py:3: in <module>
    from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet
api_yamdb/api/views.py:30: in <module>
    class GenreViewSet(viewsets.ModelViewSet):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError
______ Test03GenreAPI.test_03_category_fields_validation[data2-massage2] _______

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <rest_framework.test.ForceAuthClientHandler object at 0x7fb400354070>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

env/lib/python3.9/site-packages/django/core/handlers/base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <rest_framework.test.ForceAuthClientHandler object at 0x7fb400354070>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

env/lib/python3.9/site-packages/django/core/handlers/base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, path = '/api/v1/genres/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

env/lib/python3.9/site-packages/django/urls/resolvers.py:556: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdb20>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

env/lib/python3.9/site-packages/django/urls/resolvers.py:598: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb40040b580>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb40040b580>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb40039bb30, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb40035f820>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb40035f820>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421c29660, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x7fb4003542e0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb4106a8640>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb40040b5e0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb40040b5e0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb400480ea0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb40035f580>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb40035f580>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4004aabe0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x7fb40040bd30>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb400221fc0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb40040ba00>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb40040ba00>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4219ffc90, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb40033eee0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb40033eee0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb400218f50, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x7fb40040bcd0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb421b3dd80>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb40040b9a0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb40040b9a0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb400218920, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb40033e3a0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb40033e3a0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421b0ad40, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x7fb40040bc70>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb400221880>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb40040bac0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb40040bac0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb40047dea0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb400332a00>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb400332a00>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421b0aa80, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x7fb40040bbe0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb4002694c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb40040b190>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb40040b190>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421b0a920, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb4003320a0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb4003320a0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4218f02f0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x7fb40040bbb0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb41064f100>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb40040b880>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb40040b880>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4218f0f50, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb400358820>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb400358820>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb40020b3a0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x7fb40040b1c0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb4106db180>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb4003610d0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb4003610d0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4106a73a0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb400358a60>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb400358a60>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb400222450, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_03_genre.Test03GenreAPI object at 0x7fb400352100>
data = {'name': 'brokenslug', 'slug': ':-)'}
massage = ('Проверьте, что при обработке POST-запроса к `{url}` содержание поля `slug` проверяется на соответствие паттерну, указанному в спецификации: ^[-a-zA-Z0-9_]+$',)
admin_client = <rest_framework.test.APIClient object at 0x7fb400355280>

    @pytest.mark.parametrize('data,massage', check_name_and_slug_patterns)
    def test_03_category_fields_validation(self, data, massage, admin_client):
>       response = admin_client.post(self.GENRES_URL, data=data)

tests/test_03_genre.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
env/lib/python3.9/site-packages/rest_framework/test.py:295: in post
    response = super().post(
env/lib/python3.9/site-packages/rest_framework/test.py:209: in post
    return self.generic('POST', path, data, content_type, **extra)
env/lib/python3.9/site-packages/rest_framework/test.py:233: in generic
    return super().generic(
env/lib/python3.9/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
env/lib/python3.9/site-packages/rest_framework/test.py:285: in request
    return super().request(**kwargs)
env/lib/python3.9/site-packages/rest_framework/test.py:237: in request
    request = super().request(**kwargs)
env/lib/python3.9/site-packages/django/test/client.py:714: in request
    response = self.handler(environ)
env/lib/python3.9/site-packages/django/test/client.py:145: in __call__
    response = self.get_response(request)
env/lib/python3.9/site-packages/rest_framework/test.py:257: in get_response
    return super().get_response(request)
env/lib/python3.9/site-packages/django/core/handlers/base.py:130: in get_response
    response = self._middleware_chain(request)
env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: in inner
    response = response_for_exception(request, exc)
env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
env/lib/python3.9/site-packages/django/urls/resolvers.py:611: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
env/lib/python3.9/site-packages/django/utils/functional.py:48: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
env/lib/python3.9/site-packages/django/urls/resolvers.py:591: in urlconf_module
    return import_module(self.urlconf_name)
/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
api_yamdb/api_yamdb/urls.py:27: in <module>
    path('api/', include('api.urls')),
env/lib/python3.9/site-packages/django/urls/conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
api_yamdb/api/urls.py:3: in <module>
    from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet
api_yamdb/api/views.py:30: in <module>
    class GenreViewSet(viewsets.ModelViewSet):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError
_____________________ Test03GenreAPI.test_04_genres_delete _____________________

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <rest_framework.test.ForceAuthClientHandler object at 0x7fb421d738b0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

env/lib/python3.9/site-packages/django/core/handlers/base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <rest_framework.test.ForceAuthClientHandler object at 0x7fb421d738b0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

env/lib/python3.9/site-packages/django/core/handlers/base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, path = '/api/v1/genres/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

env/lib/python3.9/site-packages/django/urls/resolvers.py:556: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdb20>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

env/lib/python3.9/site-packages/django/urls/resolvers.py:598: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421d791f0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421d791f0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4106ce7c0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421d5a0a0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421d5a0a0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421889660, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x7fb421d73a00>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb4002f1b40>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421d79580>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421d79580>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb3e00c0be0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421b30fd0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421b30fd0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb42197ac90, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x7fb421d73820>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb421a6c140>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421d794f0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421d794f0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421a02870, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421d6ca30>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421d6ca30>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4002653a0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x7fb421d73a60>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb421b3eb80>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421d79610>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421d79610>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4106e9be0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421d6c070>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421d6c070>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421a9e5b0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x7fb421d73dc0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb421c5a480>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421d792b0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421d792b0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb42197a870, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421b47cd0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421b47cd0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb400248660, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x7fb421d73e80>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb421aaa7c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421d6fe50>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421d6fe50>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4002489d0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421b35f70>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421b35f70>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421aa7c90, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x7fb421d737f0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb4219f85c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421d6feb0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421d6feb0>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421aa7b30, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421b351f0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421b351f0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4106769d0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x7fb421d73910>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb421c4ca40>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421d5ea60>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421d5ea60>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb40023bbe0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421b4d850>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421b4d850>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4219eebe0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_03_genre.Test03GenreAPI object at 0x7fb421d79670>
admin_client = <rest_framework.test.APIClient object at 0x7fb421d6f640>

    def test_04_genres_delete(self, admin_client):
>       genres = create_genre(admin_client)

tests/test_03_genre.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/utils.py:202: in create_genre
    response = admin_client.post('/api/v1/genres/', data=data)
env/lib/python3.9/site-packages/rest_framework/test.py:295: in post
    response = super().post(
env/lib/python3.9/site-packages/rest_framework/test.py:209: in post
    return self.generic('POST', path, data, content_type, **extra)
env/lib/python3.9/site-packages/rest_framework/test.py:233: in generic
    return super().generic(
env/lib/python3.9/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
env/lib/python3.9/site-packages/rest_framework/test.py:285: in request
    return super().request(**kwargs)
env/lib/python3.9/site-packages/rest_framework/test.py:237: in request
    request = super().request(**kwargs)
env/lib/python3.9/site-packages/django/test/client.py:714: in request
    response = self.handler(environ)
env/lib/python3.9/site-packages/django/test/client.py:145: in __call__
    response = self.get_response(request)
env/lib/python3.9/site-packages/rest_framework/test.py:257: in get_response
    return super().get_response(request)
env/lib/python3.9/site-packages/django/core/handlers/base.py:130: in get_response
    response = self._middleware_chain(request)
env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: in inner
    response = response_for_exception(request, exc)
env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
env/lib/python3.9/site-packages/django/urls/resolvers.py:611: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
env/lib/python3.9/site-packages/django/utils/functional.py:48: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
env/lib/python3.9/site-packages/django/urls/resolvers.py:591: in urlconf_module
    return import_module(self.urlconf_name)
/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
api_yamdb/api_yamdb/urls.py:27: in <module>
    path('api/', include('api.urls')),
env/lib/python3.9/site-packages/django/urls/conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
api_yamdb/api/urls.py:3: in <module>
    from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet
api_yamdb/api/views.py:30: in <module>
    class GenreViewSet(viewsets.ModelViewSet):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError
________________ Test03GenreAPI.test_05_genres_check_permission ________________

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <rest_framework.test.ForceAuthClientHandler object at 0x7fb421cfe490>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
>       callback, callback_args, callback_kwargs = self.resolve_request(request)

env/lib/python3.9/site-packages/django/core/handlers/base.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <rest_framework.test.ForceAuthClientHandler object at 0x7fb421cfe490>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def resolve_request(self, request):
        """
        Retrieve/set the urlconf for the request. Return the view resolved,
        with its args and kwargs.
        """
        # Work out the resolver.
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
        # Resolve the view, and assign the match object back to the request.
>       resolver_match = resolver.resolve(request.path_info)

env/lib/python3.9/site-packages/django/core/handlers/base.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, path = '/api/v1/genres/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

env/lib/python3.9/site-packages/django/urls/resolvers.py:556: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdb20>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

env/lib/python3.9/site-packages/django/urls/resolvers.py:598: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421ce9b50>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421ce9b50>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb400222ea0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421d02af0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421d02af0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb40025bb30, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x7fb421cfe640>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb4004c1340>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421ce9820>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421ce9820>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb400222a80, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb410754af0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb410754af0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb3e00ac7c0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x7fb400354160>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb421a81500>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421ce9a90>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421ce9a90>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb3e00ac500, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb4107540d0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb4107540d0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421d522f0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x7fb4003542b0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb4219ef300>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421ce9d90>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421ce9d90>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421cd2030, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb400554400>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb400554400>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4106cec90, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x7fb400354130>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb421d174c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421ce9d60>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421ce9d60>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb40024e500, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb400554c10>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb400554c10>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421c26240, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x7fb4003540d0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb421a7db80>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421ce9520>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421ce9520>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb421c26df0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb4005523a0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb4005523a0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb40039bb30, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x7fb400354250>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb400269cc0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421ce9190>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421ce9190>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb40039b3a0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb400352cd0>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb400352cd0>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb4004702f0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x7fb421859cd0>
request = <WSGIRequest: POST '/api/v1/genres/'>

    def __call__(self, request):
        # Exit out to async mode, if needed
        if asyncio.iscoroutinefunction(self.get_response):
            return self.__acall__(request)
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

env/lib/python3.9/site-packages/django/utils/deprecation.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
exc = NameError("name 'IsAdminUser' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, BadRequest):
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                '%s: %s', str(exc), request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/genres/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'IsAdminUser' is not defined"), <traceback object at 0x7fb400269c40>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback = resolver.resolve_error_handler(500)

env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

env/lib/python3.9/site-packages/django/urls/resolvers.py:611: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x7fb4000fdac0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

env/lib/python3.9/site-packages/django/utils/functional.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        if isinstance(self.urlconf_name, str):
>           return import_module(self.urlconf_name)

env/lib/python3.9/site-packages/django/urls/resolvers.py:591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb421d05970>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb421d05970>
module = <module 'api_yamdb.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb400470be0, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api_yamdb/u... from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n", ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    """YaMDb URL Configuration
    
    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/3.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
>       path('api/', include('api.urls')),
    
    ]

api_yamdb/api_yamdb/urls.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

env/lib/python3.9/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1030: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:1007: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x7fb420099310>

>   ???

<frozen importlib._bootstrap>:986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x7fb400355850>, origin='/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:680: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x7fb400355850>
module = <module 'api.urls' from '/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:790: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x7fb400375920, file "/Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/urls.py.../Users/macbook-pro/Documents/praktikum/api_group/api_yamdb/api/__pycache__/urls.cpython-39.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.urls import include, path
    from rest_framework.routers import DefaultRouter
>   from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet

api_yamdb/api/urls.py:3: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.conf import settings
    from django.contrib.auth.tokens import default_token_generator
    from django.core.mail import send_mail
    from django.db import IntegrityError
    from rest_framework import status
    from rest_framework import viewsets
    from rest_framework.decorators import action, api_view
    from rest_framework.generics import get_object_or_404
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework_simplejwt.tokens import AccessToken
    
    from reviews.models import Category, Genre, Title
    from .permissions import IsAdminOrReadOnly
    from .serializers import (CategorySerializer, GenreSerializer,
                              TitleSerializer, TokenSerializer,
                              SignupSerializer, UserEditSerializer,
                              UserSerializer)
    from users.models import User
    
    
    class CategoryViewSet(viewsets.ModelViewSet):
        queryset = Category.objects.all()
        serializer_class = CategorySerializer
        lookup_field = 'slug'
        permission_classes = [IsAdminOrReadOnly]
    
    
>   class GenreViewSet(viewsets.ModelViewSet):

api_yamdb/api/views.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_03_genre.Test03GenreAPI object at 0x7fb421d058b0>
client = <django.test.client.Client object at 0x7fb421ac3a90>
user_client = <rest_framework.test.APIClient object at 0x7fb421cfe130>
moderator_client = <rest_framework.test.APIClient object at 0x7fb421cfe370>
admin_client = <rest_framework.test.APIClient object at 0x7fb421cfe400>

    def test_05_genres_check_permission(self, client,
                                        user_client,
                                        moderator_client,
                                        admin_client):
>       genres = create_genre(admin_client)

tests/test_03_genre.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/utils.py:202: in create_genre
    response = admin_client.post('/api/v1/genres/', data=data)
env/lib/python3.9/site-packages/rest_framework/test.py:295: in post
    response = super().post(
env/lib/python3.9/site-packages/rest_framework/test.py:209: in post
    return self.generic('POST', path, data, content_type, **extra)
env/lib/python3.9/site-packages/rest_framework/test.py:233: in generic
    return super().generic(
env/lib/python3.9/site-packages/django/test/client.py:473: in generic
    return self.request(**r)
env/lib/python3.9/site-packages/rest_framework/test.py:285: in request
    return super().request(**kwargs)
env/lib/python3.9/site-packages/rest_framework/test.py:237: in request
    request = super().request(**kwargs)
env/lib/python3.9/site-packages/django/test/client.py:714: in request
    response = self.handler(environ)
env/lib/python3.9/site-packages/django/test/client.py:145: in __call__
    response = self.get_response(request)
env/lib/python3.9/site-packages/rest_framework/test.py:257: in get_response
    return super().get_response(request)
env/lib/python3.9/site-packages/django/core/handlers/base.py:130: in get_response
    response = self._middleware_chain(request)
env/lib/python3.9/site-packages/django/core/handlers/exception.py:49: in inner
    response = response_for_exception(request, exc)
env/lib/python3.9/site-packages/django/core/handlers/exception.py:114: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
env/lib/python3.9/site-packages/django/core/handlers/exception.py:152: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
env/lib/python3.9/site-packages/django/urls/resolvers.py:611: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
env/lib/python3.9/site-packages/django/utils/functional.py:48: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
env/lib/python3.9/site-packages/django/urls/resolvers.py:591: in urlconf_module
    return import_module(self.urlconf_name)
/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
api_yamdb/api_yamdb/urls.py:27: in <module>
    path('api/', include('api.urls')),
env/lib/python3.9/site-packages/django/urls/conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1030: in _gcd_import
    ???
<frozen importlib._bootstrap>:1007: in _find_and_load
    ???
<frozen importlib._bootstrap>:986: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:680: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:790: in exec_module
    ???
<frozen importlib._bootstrap>:228: in _call_with_frames_removed
    ???
api_yamdb/api/urls.py:3: in <module>
    from api.views import CategoryViewSet, GenreViewSet, TitleViewSet, UserViewSet
api_yamdb/api/views.py:30: in <module>
    class GenreViewSet(viewsets.ModelViewSet):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class GenreViewSet(viewsets.ModelViewSet):
        queryset = Genre.objects.all()
        serializer_class = GenreSerializer
        lookup_field = 'slug'
>       permission_classes = [IsAdminUser]  # Доступ только для администраторов
E       NameError: name 'IsAdminUser' is not defined

api_yamdb/api/views.py:34: NameError
--------------------------- Captured stderr teardown ---------------------------
Destroying test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
=========================== short test summary info ============================
FAILED tests/test_03_genre.py::Test03GenreAPI::test_01_genre_not_auth - NameE...
FAILED tests/test_03_genre.py::Test03GenreAPI::test_02_genre - NameError: nam...
FAILED tests/test_03_genre.py::Test03GenreAPI::test_03_category_fields_validation[data0-massage0]
FAILED tests/test_03_genre.py::Test03GenreAPI::test_03_category_fields_validation[data1-massage1]
FAILED tests/test_03_genre.py::Test03GenreAPI::test_03_category_fields_validation[data2-massage2]
FAILED tests/test_03_genre.py::Test03GenreAPI::test_04_genres_delete - NameEr...
FAILED tests/test_03_genre.py::Test03GenreAPI::test_05_genres_check_permission
============================== 7 failed in 3.81s ===============================
